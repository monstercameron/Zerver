/// Core helpers: step trampoline, effect constructors, decision utilities.
const std = @import("std");
const types = @import("types.zig");
const ctx_module = @import("ctx.zig");

/// Wrap a typed step function into a Step struct.
/// This allows the framework to call typed step functions through a generic interface.
///
/// Expected function signature: fn (*CtxView(spec)) !Decision
/// The spec must be a comptime-known struct with optional .reads and .writes fields.
pub fn step(comptime name: []const u8, comptime F: anytype) types.Step {
    const FInfo = @typeInfo(F);

    // F must be a function
    if (FInfo != .Fn) {
        @compileError("step() expects a function, got " ++ @typeName(F));
    }

    // Extract the first parameter type (should be *CtxView(spec))
    if (FInfo.Fn.params.len < 1) {
        @compileError("step function must have at least one parameter (*CtxView)");
    }

    const CtxViewPtr = FInfo.Fn.params[0].type.?;
    const CtxViewType = switch (@typeInfo(CtxViewPtr)) {
        .Pointer => |ptr| ptr.child,
        else => @compileError("First parameter must be a pointer type"),
    };

    // Now extract the spec from CtxView - it's passed as a comptime generic parameter
    // CtxView is generated by: pub fn CtxView(comptime spec: anytype) type
    // We need to find what spec was used. Since CtxView stores it in its type info,
    // we can inspect the type name to deduce it, but that's fragile.
    // Better approach: CtxView needs to expose the spec or we extract from context.

    // For now, we'll extract reads/writes from the CtxView's methods if they exist
    const ReadsWrites = extractReadsWrites(CtxViewType);

    return types.Step{
        .name = name,
        .call = makeTrampolineFor(F, CtxViewPtr),
        .reads = ReadsWrites.reads,
        .writes = ReadsWrites.writes,
    };
}

/// Extract reads and writes from a CtxView type by inspecting its public decls.
fn extractReadsWrites(comptime _CtxViewType: type) struct { reads: []const u32, writes: []const u32 } {
    // For now, return empty - will be populated by context when spec is available
    // The Step struct can be annotated separately, or we could enhance CtxView
    // to expose its spec via a public const field.
    _ = _CtxViewType;
    return .{
        .reads = &.{},
        .writes = &.{},
    };
}

/// Create a wrapper function that adapts from *CtxBase to the typed view expected by F.
fn makeTrampolineFor(comptime F: anytype, comptime CtxViewPtr: anytype) *const fn (*anyopaque) anyerror!types.Decision {
    return struct {
        pub fn wrapper(base: *anyopaque) anyerror!types.Decision {
            const ctx_base: *ctx_module.CtxBase = @ptrCast(@alignCast(base));

            // Create a CtxView instance - extract the type from the pointer
            const CtxViewType = @typeInfo(CtxViewPtr).Pointer.child;

            // Instantiate the CtxView with the base context
            var view: CtxViewType = undefined;

            // CtxView fields should be: base: *CtxBase
            // We set it manually
            if (@hasField(CtxViewType, "base")) {
                @field(view, "base") = ctx_base;
            } else {
                @compileError("CtxView must have a 'base' field of type *CtxBase");
            }

            // Call the typed function with the view
            return F(&view);
        }
    }.wrapper;
}

/// Helper to create a Decision.Continue.
pub fn continue_() types.Decision {
    return .Continue;
}

/// Helper to create a Decision.Done.
pub fn done(resp: types.Response) types.Decision {
    return .{ .Done = resp };
}

/// Helper to create a Decision.Fail.
pub fn fail(kind: u16, what: []const u8, key: []const u8) types.Decision {
    return .{ .Fail = .{
        .kind = kind,
        .ctx = .{ .what = what, .key = key },
    } };
}

/// Re-export ErrorCode for convenience
pub const ErrorCode = types.ErrorCode;
